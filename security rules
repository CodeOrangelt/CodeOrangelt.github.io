rules_version = '2';
function isSignedIn() {
  return request.auth != null;
}

function isAdmin() {
  let adminEmails = ['admin@ladder.com', 'brian2af@outlook.com'];
  return request.auth != null && 
    adminEmails.hasAny([request.auth.token.email.toLowerCase()]);
}

function isVerifiedUser() {
  return request.auth != null;
}

// Update isMatchParticipant function to fix typo and add winner check
function isMatchParticipant(matchData) {
  return request.auth != null && (
    matchData.winnerEmail == request.auth.token.email ||
    matchData.loserEmail == request.auth.token.email
  );
}

function isMatchWinner(matchData) {
  return request.auth != null && 
    matchData.winnerEmail == request.auth.token.email;
}

function isValidEloUpdate(currentData, newData) {
  return newData.eloRating is number &&
         currentData.eloRating is number &&
         (newData.eloRating - currentData.eloRating) <= 32 &&
         (newData.eloRating - currentData.eloRating) >= -32;
}

// Update isValidPromotion and isValidDemotion to be more permissive
function isValidPromotion(currentData, newData) {
  return newData.eloRating is number &&
         currentData.eloRating is number;
}

function isValidDemotion(currentData, newData) {
  return newData.eloRating is number &&
         currentData.eloRating is number;
}

service cloud.firestore {
  match /databases/{database}/documents {
    // Players collection - Used in ladderalgorithm.js and ladder.js
    match /players/{playerId} {
      allow read: if true;
      allow create: if isVerifiedUser();
      allow update: if isAdmin() || 
                   request.auth.uid == playerId || 
                   (request.resource.data.diff(resource.data).affectedKeys()
                    .hasAll(['eloRating', 'lastMatchDate', 'position']) &&
                    isValidEloUpdate(resource.data, request.resource.data));
      allow delete: if isAdmin();
    }

    // Match Management - Used in reports.js and ladderalgorithm.js
    match /pendingMatches/{matchId} {
      allow read: if true;
      allow create: if request.auth != null && 
                   request.resource.data.keys().hasAll([
                     'winnerUsername', 'loserUsername', 'winnerEmail', 'loserEmail',
                     'reportedBy', 'createdAt'
                   ]) &&
                   (
                     // Either winner or loser can create the match report
                     request.auth.token.email == request.resource.data.winnerEmail ||
                     request.auth.token.email == request.resource.data.loserEmail
                   );
      // Allow participants to update their own match details
      allow update: if isMatchParticipant(resource.data);
      // Only participants can delete their pending matches
      allow delete: if isMatchParticipant(resource.data);
    }

    match /approvedMatches/{matchId} {
      allow read: if true;
      allow create: if request.auth != null && 
                   request.resource.data.keys().hasAll([
                     'winnerScore', 'winnerComment', 'approved',
                     'approvedAt', 'approvedBy'
                   ]) && 
                   request.auth.token.email == request.resource.data.winnerEmail;
      allow update: if isMatchParticipant(resource.data);
      allow delete: if false;  // Keep match history immutable
    }

    // ELO History - Used in elo-history.js and ladderalgorithm.js
    match /eloHistory/{historyId} {
      allow read: if true;
      allow create: if request.auth != null && 
                   (
                     // Regular match history
                     (request.resource.data.type == 'match' &&
                      request.resource.data.keys().hasAll([
                        'type', 'player', 'opponent',
                        'previousElo', 'newElo', 'change',
                        'matchResult', 'previousPosition', 'newPosition',
                        'timestamp'
                      ])) ||
                     // Simplified promotion/demotion rules
                     ((request.resource.data.type == 'promotion' ||
                       request.resource.data.type == 'demotion') &&
                      request.resource.data.keys().hasAll([
                        'type',
                        'player',
                        'previousElo',
                        'newElo',
                        'timestamp'
                      ]) &&
                      isAdmin())
                   );
      allow update, delete: if false;  // Keep history immutable
    }

    // RetroTracker - Used in whosplaying.js
    match /retroTracker/{docId} {
      allow read: if true;
      allow create: if request.auth != null && 
                   request.resource.data.keys().hasAll([
                     'gameName', 'players', 'timestamp'
                   ]);
      allow write: if request.auth != null;
    }

    // Season Management - Used in season-manager.js
    match /metadata/seasonCount {
      allow read: if true;
      allow write: if isAdmin();
    }

    match /seasons/{seasonId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // User Profiles - Used in profile-viewer.js
    match /userProfiles/{userId} {
      allow read: if true;
      allow create, update: if request.auth != null && 
                           (request.auth.uid == userId || isAdmin());
      allow delete: if isAdmin();
    }

    // Promotion views tracking
    match /promotionViews/{viewId} {
      allow read: if request.auth != null && 
                 viewId.matches('^.*_' + request.auth.uid + '$');
      allow create, update: if request.auth != null && 
                          viewId.matches('^.*_' + request.auth.uid + '$') &&
                          request.resource.data.keys().hasOnly(['views']) &&
                          request.resource.data.views <= 5;
    }

    // Player Stats collection
    match /playerStats/{userId} {
      allow read: if true;
      allow write: if isSignedIn() && 
        (request.auth.uid == userId || isAdmin());
    }
  }
}